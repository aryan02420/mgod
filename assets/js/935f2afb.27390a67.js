"use strict";(self.webpackChunkmgod=self.webpackChunkmgod||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"category","label":"Introduction","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"About","href":"/mgod/docs/introduction/about","docId":"introduction/about","unlisted":false}]},{"type":"category","label":"Beginner\'s Guide","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Installation","href":"/mgod/docs/beginners-guide/installation","docId":"beginners-guide/installation","unlisted":false},{"type":"link","label":"Basic Usage","href":"/mgod/docs/beginners-guide/basic_usage","docId":"beginners-guide/basic_usage","unlisted":false}]},{"type":"category","label":"Features","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Schema Options","href":"/mgod/docs/features/schema_options","docId":"features/schema_options","unlisted":false},{"type":"link","label":"Field Options","href":"/mgod/docs/features/field_options","docId":"features/field_options","unlisted":false},{"type":"link","label":"Field Transformers","href":"/mgod/docs/features/field_transformers","docId":"features/field_transformers","unlisted":false},{"type":"link","label":"Meta Fields","href":"/mgod/docs/features/meta_fields","docId":"features/meta_fields","unlisted":false}]},{"type":"category","label":"Advanced Guide","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Union Types","href":"/mgod/docs/advanced-guide/union_types","docId":"advanced-guide/union_types","unlisted":false}]}]},"docs":{"advanced-guide/union_types":{"id":"advanced-guide/union_types","title":"Union Types","description":"Sometimes its possible that the API needs to be flexible and support a range of types. An example for this might be a tagging functionality on resources such as user, movies, etc. The CRUD layer for tags entity needs to support operations on multiple types of tags like NumberTag, DateTag, etc. through same functions.","sidebar":"docsSidebar"},"beginners-guide/basic_usage":{"id":"beginners-guide/basic_usage","title":"Basic Usage","description":"Add tags (wherever applicable) in existing struct (or define a new model).","sidebar":"docsSidebar"},"beginners-guide/installation":{"id":"beginners-guide/installation","title":"Installation","description":"Requirements","sidebar":"docsSidebar"},"features/field_options":{"id":"features/field_options","title":"Field Options","description":"Field Options are custom schema options available at field level (for fields of struct type). These options either modifies the schema or adds validations to the field on which it is applied.","sidebar":"docsSidebar"},"features/field_transformers":{"id":"features/field_transformers","title":"Field Transformers","description":"Field transformers are an adapter between MongoDB field and Go struct field. They help in transforming field types in both directions i.e. from entity model to mongo doc and vice versa while building intermediate BSON document.","sidebar":"docsSidebar"},"features/meta_fields":{"id":"features/meta_fields","title":"Meta Fields","description":"Meta fields are those fields that tracks extra information about the document which can be helpful to determine the state of a document.","sidebar":"docsSidebar"},"features/schema_options":{"id":"features/schema_options","title":"Schema Options","description":"Schema Options is Mongo Schema level options (which modifies actual MongoDB doc) that needs to be provided when creating a new EntityMongoModel.","sidebar":"docsSidebar"},"introduction/about":{"id":"introduction/about","title":"About","description":"What is mgod?","sidebar":"docsSidebar"}}}')}}]);
"use strict";(self.webpackChunkmgod=self.webpackChunkmgod||[]).push([[756],{1137:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(5893),s=t(1151);const o={title:"Union Types",sidebar_position:1},i=void 0,r={id:"advanced-guide/union_types",title:"Union Types",description:"Sometimes its possible that the API needs to be flexible and support a range of types. An example for this might be a tagging functionality on resources such as user, movies, etc. The CRUD layer for tags entity needs to support operations on multiple types of tags like NumberTag, DateTag, etc. through same functions.",source:"@site/../docs/advanced-guide/union_types.md",sourceDirName:"advanced-guide",slug:"/advanced-guide/union_types",permalink:"/mgod/docs/advanced-guide/union_types",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Union Types",sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Meta Fields",permalink:"/mgod/docs/features/meta_fields"}},d={},c=[{value:"Usage",id:"usage",level:2}];function l(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Sometimes its possible that the API needs to be flexible and support a range of types. An example for this might be a tagging functionality on resources such as user, movies, etc. The CRUD layer for tags entity needs to support operations on multiple types of tags like ",(0,a.jsx)(n.code,{children:"NumberTag"}),", ",(0,a.jsx)(n.code,{children:"DateTag"}),", etc. through same functions."]}),"\n",(0,a.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsxs)(n.p,{children:["In Go, to create union types, we need to create a base type and then use it as a struct embedding in children types. For instance, here we are creating two children tag types - ",(0,a.jsx)(n.code,{children:"NumberTag"})," and ",(0,a.jsx)(n.code,{children:"DateTag"})," with ",(0,a.jsx)(n.code,{children:"BaseTag"})," as the base type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'type TagTypeEnum string\n\nconst (\n\tTagTypeEnumNumber TagTypeEnum = "number"\n\tTagTypeEnumDate   TagTypeEnum = "date"\n)\n\ntype BaseTag struct {\n\tID   string `bson:"_id" mgoType:"id"`\n\tName string\n\tType TagTypeEnum\n}\n\nfunc (BaseTag) IsTag() {}\n\ntype NumberTag struct {\n\tBaseTag `bson:",inline"`\n\tNumber  int\n}\n\ntype DateTag struct {\n\tBaseTag `bson:",inline"`\n\tDate    string `mgoType:"date"`\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Though we know the type of the doc while insertion, it might not be possible to know the doc type beforehand while querying a collection that stores multiple types of docs like in the case of union types. So, we need a global type that can receive the doc for any of the union types."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'type GlobalTag struct {\n\tBaseTag `bson:",inline"`\n\tNumber  *int    `bson:",omitempty"`\n\tDate    *string `bson:",omitempty" mgoType:"date"`\n}\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Only common fields are kept as compulsory whereas other fields are marked optional."})}),"\n",(0,a.jsx)(n.p,{children:"Configure schema options for the union type entities."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'// As the `type` field is the discriminator in this case, we can define the DiscriminatorKey rather than relying on auto creation of `__t` field.\ndiscriminator := "type"\nschemaOpts := schemaopt.SchemaOptions{\n\tCollection:       "unionTest",\n\tTimestamps:       true,\n\tIsUnionType:      true,\n\tDiscriminatorKey: &discriminator,\n}\n\n// dbConn is the database connection obtained using Go Mongo Driver\'s Connect method.\ntagModelOpts := mgod.NewEntityMongoOptions(dbConn, schemaOpts)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Create ODM for entities using ",(0,a.jsx)(n.code,{children:"mgod"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"globalTagModel, _ := mgod.NewEntityMongoModel(GlobalTag{}, *tagModelOpts)\nnumberTagModel, _ := mgod.NewEntityMongoModel(NumberTag{}, *tagModelOpts)\ndateTagModel, _ := mgod.NewEntityMongoModel(DateTag{}, *tagModelOpts)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now, to insert documents, we have two options -"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Use ODM specific to the entity we are inserting in case we have liberty to create separate functions to handle different entities."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'numberTag := NumberTag{\n\t\tBaseTag: BaseTag{\n\t\t\tID:   primitive.NewObjectID().Hex(),\n\t\t\tName: "numberTag",\n\t\t\tType: TagTypeEnumNumber,\n\t\t},\n\t\tNumber: 1,\n\t}\n\ninsertedNumberTag, _ := numberTagModel.InsertOne(context.TODO(), numberTag)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Output:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n\t"_id" : ObjectId("65718f9c55e90b39cf538b42"),\n\t"name" : "numberTag",\n\t"type" : "number",\n\t"number" : 1,\n\t"createdAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"updatedAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"__v" : 0\n}\n'})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Use global ODM to insert the doc that is created using the entity ODM. This is helpful in case where we want a common function handle the inserting of entities."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'date, _ := dateformatter.New(time.Now().UTC()).GetISOString()\ndateTag := DateTag{\n\t\tBaseTag: BaseTag{\n\t\t\tID:   primitive.NewObjectID().Hex(),\n\t\t\tName: "dateTag",\n\t\t\tType: TagTypeEnumDate,\n\t\t},\n\t\tDate: date,\n\t}\n\ndateTagDoc, _ := dateTagModel.GetDocToInsert(context.TODO(), numberTag)\n\ninsertedDateTag, _ := globalTagModel.InsertOne(context.TODO(), dateTagDoc)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Output:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n\t"_id" : ObjectId("65718f9c55e90b39cf538b43"),\n\t"name" : "dateTag",\n\t"type" : "date",\n\t"date" : ISODate("2023-12-07T09:25:48.252Z"),\n\t"createdAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"updatedAt" : ISODate("2023-12-07T09:25:48.253Z"),\n\t"__v" : 0\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Use the global ODM to find docs by querying on model properties."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'numberTag, _ := globalTagModel.FindOne(context.TODO(), bson.M{"name": "numberTag"})\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Output:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'GlobalTag{\n\tBaseTag{\n\t\tID: "65718f9c55e90b39cf538b42",\n\t\tName: "numberTag",\n\t\tType: "number",\n\t},\n\tNumber: 0x1400030c380, // pointer to value of 1\n\tDate: <nil>,\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In the above step, before returning the results, all docs received from the MongoDB are validated and processed against their respective typed models based on the discriminator key (here the ",(0,a.jsx)(n.code,{children:"type"})," field). So, in the above step, the number tag document is processed against the schema for NumberTag type before getting converted to the GlobalTag type."]})]})}function g(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>i});var a=t(7294);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);